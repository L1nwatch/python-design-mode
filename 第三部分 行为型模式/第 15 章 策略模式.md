## 第 15 章 策略模式

大多数问题都可以使用多种方法来解决。通常来说，没有公认最适合所有场景的算法。

一些不同的评判标准能帮助我们为不同的场景选择不同的排序算法，其中应该考虑的有以下几个：

*   需要排序的元素数量：这被称为输入大小。当输入较少时，几乎所有排序算法的表现都很好，但对于大量输入，只有部分算法具有不错的性能。 
*   算法的最佳/平均/最差时间复杂度：时间复杂度是算法运行完成所花费的（大致）时间长短，不考虑系数和低阶项 ① 。这是选择算法的最常见标准，但这个标准并不总是那么充分。
*   算法的空间复杂度：空间复杂度是充分地运行一个算法所需要的（大致）物理内存量。在我们处理大数据或在嵌入式系统（通常内存有限）中工作时，这个因素非常重要。 
*   算法的稳定性：在执行一个排序算法之后，如果能保持相等值元素原来的先后相对次序，则认为它是稳定的。
*   算法的代码实现复杂度：如果两个算法具有相同的时间/空间复杂度，并且都是稳定的，那么知道哪个算法更易于编码实现和维护也是很重要的。

策略模式（Strategy pattern）鼓励使用多种算法来解决一个问题，其杀手级特性是能够在运行时透明地切换算法（客户端代码对变化无感知）。

### 15.1 现实生活的例子

去机场赶飞机是现实中使用策略模式的一个恰当例子。

### 15.2 软件的例子

Python 的 `sorted()` 和 `list.sort()` 函数是策略模式的例子。两个函数都接受一个命名参数 key，这个参数本质上是实现了一个排序策略的函数的名称。

pprint 模块用于美化输出一个数据结构， attrgetter 用于通过属性名访问 class 或 namedtuple 的属性。也可以使用一个 lambda 函数来替代使用 attrgetter，但作者觉得 attrgetter 的可读性更高。

```python
import pprint
from collections import namedtuple
from operator import attrgetter
if __name__ == '__main__':
    ProgrammingLang = namedtuple('ProgrammingLang', 'name ranking')
    stats = (('Ruby', 14), ('Javascript', 8), ('Python', 7),
             ('Scala', 31), ('Swift', 18), ('Lisp', 23))
    lang_stats = [ProgrammingLang(n, r) for n, r in stats]
    pp = pprint.PrettyPrinter(indent=5)
    pp.pprint(sorted(lang_stats, key=attrgetter('name')))
    print()
    pp.pprint(sorted(lang_stats, key=attrgetter('ranking')))
```

Java API 也使用了策略设计模式。`java.util.Comparator` 是一个接口，包含一个 `compare()` 方法，该方法本质上是一个策略，可传给排序方法，比如 `Collections.sort` 和 `Arrays.sort`。

### 15.3 应用案例

